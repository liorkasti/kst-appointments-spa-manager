{"ast":null,"code":"var _s = $RefreshSig$();\nimport jsonpatch from 'fast-json-patch';\nimport { useMutation, useQueryClient } from 'react-query';\nimport { axiosInstance, getJWTHeader } from '../../../axiosInstance';\nimport { queryKeys } from '../../../react-query/constants';\nimport { useCustomToast } from '../../app/hooks/useCustomToast';\nimport { useUser } from './useUser';\n\n// for when we need a server function\nasync function patchUserOnServer(newData, originalData) {\n  if (!newData || !originalData) return null;\n  // create a patch for the difference between newData and originalData\n  const patch = jsonpatch.compare(originalData, newData);\n\n  // send patched data to the server\n  const {\n    data\n  } = await axiosInstance.patch(`/user/${originalData.id}`, {\n    patch\n  }, {\n    headers: getJWTHeader(originalData)\n  });\n  return data.user;\n}\nexport function usePatchUser() {\n  _s();\n  const {\n    user,\n    updateUser\n  } = useUser();\n  const toast = useCustomToast();\n  const queryClient = useQueryClient();\n  const {\n    mutate: patchUser\n  } = useMutation(newUserData => patchUserOnServer(newUserData, user), {\n    // onMutate returns context that is passed to onError\n    onMutate: async newData => {\n      // cancel any outgoing queries for user data, so old server data\n      // doesn't overwrite our optimistic update\n      queryClient.cancelQueries(queryKeys.user);\n\n      // snapshot of previous user value\n      const previousUserData = queryClient.getQueryData(queryKeys.user);\n\n      // optimistically update the cache with new user value\n      updateUser(newData);\n\n      // return context object with snapshotted value\n      return {\n        previousUserData\n      };\n    },\n    onError: (error, newData, context) => {\n      // roll back cache to saved value\n      if (context.previousUserData) {\n        updateUser(context.previousUserData);\n        toast({\n          title: 'Update failed; restoring previous values',\n          status: 'warning'\n        });\n      }\n    },\n    onSuccess: userData => {\n      // note: the conditional here should be `userData`, not `user` as shown\n      //   in the video.\n      // see: https://www.udemy.com/course/learn-react-query/learn/#questions/18361988/\n      if (userData) {\n        toast({\n          title: 'User updated!',\n          status: 'success'\n        });\n      }\n    },\n    onSettled: () => {\n      // invalidate user query to make sure we're in sync with server data\n      queryClient.invalidateQueries(queryKeys.user);\n    }\n  });\n  return patchUser;\n}\n_s(usePatchUser, \"7cj5AKVt9P+SDRO7AdycYdtc0IE=\", false, function () {\n  return [useUser, useCustomToast, useQueryClient, useMutation];\n});","map":{"version":3,"names":["jsonpatch","useMutation","useQueryClient","axiosInstance","getJWTHeader","queryKeys","useCustomToast","useUser","patchUserOnServer","newData","originalData","patch","compare","data","id","headers","user","usePatchUser","_s","updateUser","toast","queryClient","mutate","patchUser","newUserData","onMutate","cancelQueries","previousUserData","getQueryData","onError","error","context","title","status","onSuccess","userData","onSettled","invalidateQueries"],"sources":["/Users/liorkastenbaum/Repos/kst-appointments-manager-app/client/src/components/user/hooks/usePatchUser.ts"],"sourcesContent":["import jsonpatch from 'fast-json-patch';\nimport { UseMutateFunction, useMutation, useQueryClient } from 'react-query';\n\nimport type { User } from '../../../../../shared/types';\nimport { axiosInstance, getJWTHeader } from '../../../axiosInstance';\nimport { queryKeys } from '../../../react-query/constants';\nimport { useCustomToast } from '../../app/hooks/useCustomToast';\nimport { useUser } from './useUser';\n\n// for when we need a server function\nasync function patchUserOnServer(\n  newData: User | null,\n  originalData: User | null,\n): Promise<User | null> {\n  if (!newData || !originalData) return null;\n  // create a patch for the difference between newData and originalData\n  const patch = jsonpatch.compare(originalData, newData);\n\n  // send patched data to the server\n  const { data } = await axiosInstance.patch(\n    `/user/${originalData.id}`,\n    { patch },\n    {\n      headers: getJWTHeader(originalData),\n    },\n  );\n  return data.user;\n}\n\nexport function usePatchUser(): UseMutateFunction<\n  User,\n  unknown,\n  User,\n  unknown\n> {\n  const { user, updateUser } = useUser();\n  const toast = useCustomToast();\n  const queryClient = useQueryClient();\n\n  const { mutate: patchUser } = useMutation(\n    (newUserData: User) => patchUserOnServer(newUserData, user),\n    {\n      // onMutate returns context that is passed to onError\n      onMutate: async (newData: User | null) => {\n        // cancel any outgoing queries for user data, so old server data\n        // doesn't overwrite our optimistic update\n        queryClient.cancelQueries(queryKeys.user);\n\n        // snapshot of previous user value\n        const previousUserData: User = queryClient.getQueryData(queryKeys.user);\n\n        // optimistically update the cache with new user value\n        updateUser(newData);\n\n        // return context object with snapshotted value\n        return { previousUserData };\n      },\n      onError: (error, newData, context) => {\n        // roll back cache to saved value\n        if (context.previousUserData) {\n          updateUser(context.previousUserData);\n          toast({\n            title: 'Update failed; restoring previous values',\n            status: 'warning',\n          });\n        }\n      },\n      onSuccess: (userData: User | null) => {\n        // note: the conditional here should be `userData`, not `user` as shown\n        //   in the video.\n        // see: https://www.udemy.com/course/learn-react-query/learn/#questions/18361988/\n        if (userData) {\n          toast({\n            title: 'User updated!',\n            status: 'success',\n          });\n        }\n      },\n      onSettled: () => {\n        // invalidate user query to make sure we're in sync with server data\n        queryClient.invalidateQueries(queryKeys.user);\n      },\n    },\n  );\n\n  return patchUser;\n}\n"],"mappings":";AAAA,OAAOA,SAAS,MAAM,iBAAiB;AACvC,SAA4BC,WAAW,EAAEC,cAAc,QAAQ,aAAa;AAG5E,SAASC,aAAa,EAAEC,YAAY,QAAQ,wBAAwB;AACpE,SAASC,SAAS,QAAQ,gCAAgC;AAC1D,SAASC,cAAc,QAAQ,gCAAgC;AAC/D,SAASC,OAAO,QAAQ,WAAW;;AAEnC;AACA,eAAeC,iBAAiBA,CAC9BC,OAAoB,EACpBC,YAAyB,EACH;EACtB,IAAI,CAACD,OAAO,IAAI,CAACC,YAAY,EAAE,OAAO,IAAI;EAC1C;EACA,MAAMC,KAAK,GAAGX,SAAS,CAACY,OAAO,CAACF,YAAY,EAAED,OAAO,CAAC;;EAEtD;EACA,MAAM;IAAEI;EAAK,CAAC,GAAG,MAAMV,aAAa,CAACQ,KAAK,CACvC,SAAQD,YAAY,CAACI,EAAG,EAAC,EAC1B;IAAEH;EAAM,CAAC,EACT;IACEI,OAAO,EAAEX,YAAY,CAACM,YAAY;EACpC,CACF,CAAC;EACD,OAAOG,IAAI,CAACG,IAAI;AAClB;AAEA,OAAO,SAASC,YAAYA,CAAA,EAK1B;EAAAC,EAAA;EACA,MAAM;IAAEF,IAAI;IAAEG;EAAW,CAAC,GAAGZ,OAAO,CAAC,CAAC;EACtC,MAAMa,KAAK,GAAGd,cAAc,CAAC,CAAC;EAC9B,MAAMe,WAAW,GAAGnB,cAAc,CAAC,CAAC;EAEpC,MAAM;IAAEoB,MAAM,EAAEC;EAAU,CAAC,GAAGtB,WAAW,CACtCuB,WAAiB,IAAKhB,iBAAiB,CAACgB,WAAW,EAAER,IAAI,CAAC,EAC3D;IACE;IACAS,QAAQ,EAAE,MAAOhB,OAAoB,IAAK;MACxC;MACA;MACAY,WAAW,CAACK,aAAa,CAACrB,SAAS,CAACW,IAAI,CAAC;;MAEzC;MACA,MAAMW,gBAAsB,GAAGN,WAAW,CAACO,YAAY,CAACvB,SAAS,CAACW,IAAI,CAAC;;MAEvE;MACAG,UAAU,CAACV,OAAO,CAAC;;MAEnB;MACA,OAAO;QAAEkB;MAAiB,CAAC;IAC7B,CAAC;IACDE,OAAO,EAAEA,CAACC,KAAK,EAAErB,OAAO,EAAEsB,OAAO,KAAK;MACpC;MACA,IAAIA,OAAO,CAACJ,gBAAgB,EAAE;QAC5BR,UAAU,CAACY,OAAO,CAACJ,gBAAgB,CAAC;QACpCP,KAAK,CAAC;UACJY,KAAK,EAAE,0CAA0C;UACjDC,MAAM,EAAE;QACV,CAAC,CAAC;MACJ;IACF,CAAC;IACDC,SAAS,EAAGC,QAAqB,IAAK;MACpC;MACA;MACA;MACA,IAAIA,QAAQ,EAAE;QACZf,KAAK,CAAC;UACJY,KAAK,EAAE,eAAe;UACtBC,MAAM,EAAE;QACV,CAAC,CAAC;MACJ;IACF,CAAC;IACDG,SAAS,EAAEA,CAAA,KAAM;MACf;MACAf,WAAW,CAACgB,iBAAiB,CAAChC,SAAS,CAACW,IAAI,CAAC;IAC/C;EACF,CACF,CAAC;EAED,OAAOO,SAAS;AAClB;AAACL,EAAA,CAzDeD,YAAY;EAAA,QAMGV,OAAO,EACtBD,cAAc,EACRJ,cAAc,EAEJD,WAAW;AAAA"},"metadata":{},"sourceType":"module"}